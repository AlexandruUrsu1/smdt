    ###############################################################################
#   File: db.py
#   Author(s): Paul Johnecheck
#   Date Created: 11 April, 2021
#
#   Purpose: This is the class representing the database.
#    It will act as the main interface for reading and writing to the database. 
#
#   Known Issues:
#
#   Workarounds:
#
###############################################################################


# Import Preparation block.
# Currently only needed so the records in the mains work with the current imports.
import os
import sys

# Gets the path of the current file being executed.
path = os.path.realpath(__file__)
current_folder = os.path.dirname(os.path.abspath(__file__))
new_data_folder = os.path.join(current_folder, "new_data")
# Adds the folder that file is in to the system path

sys.path.append(path[:-len(os.path.basename(__file__))])

from tube import Tube
from data.dark_current import DarkCurrent, DarkCurrentRecord
from data.station import *
import locks
import shelve
import pickle
import time
import datetime
import random


class db:
    def __init__(self, path="database.s"):
        self.path = path
        
    def size(self):
        db_lock = locks.Lock("database")
        db_lock.wait()
        tubes = shelve.open(self.path)
        ret_size = len(tubes)
        tubes.close()
        return ret_size
        
       
    def add_tube(self, tube: Tube()):
        
        dt = datetime.datetime.now()
        timestamp = dt.timestamp()

        filename = str(timestamp) + str(random.randrange(0,999)) + ".p"

        with open(os.path.join(new_data_folder, filename),"wb") as f:
            pickle.dump(tube, f)

    def get_tube(self, id):
        db_lock = locks.Lock("database")
        db_lock.wait()
        tubes = shelve.open(self.path)
        try:
            ret_tube = tubes[id]
        except KeyError:
            tubes.close()
            raise KeyError
        tubes.close()
        return ret_tube

    


#This object will eventually be moved to the legacy class.
class station_pickler:
    '''
    This class is designed to facilitate the interface between the database manager and the data generated by the stations. 
    This class will take whatever data is generated in the form of a csv file, and will read it into a sMDT tube object. 
    It will then pickle the object into the standard specified for new data for the db manager.
    '''
    def __init__(self):
        pass
    def pickle_swage(self):
        pass
    def pickle_tension(self):
        pass
    def pickle_leak(self):
        pass
    def pickle_darkcurrent(self):
        pass




class db_manager():
    def __init__(self, path="database.s"):
        self.path = path

    def wipe(self):
        db_lock = locks.Lock("database")
        db_lock.lock()

        tubes = shelve.open(self.path)
        for key in tubes:
            del tubes[key]

        tubes.close()

        db_lock.unlock()

    def update(self):
        
        

        pickler = station_pickler()
        pickler.pickle_swage()
        pickler.pickle_tension()
        pickler.pickle_leak()
        pickler.pickle_darkcurrent()



        #Lock the database
        db_lock = locks.Lock("database")
        db_lock.lock()

        tubes = shelve.open(self.path)

        for filename in os.listdir(new_data_folder):
            if filename.endswith(".p"):
                new_data_file = open(os.path.join(new_data_folder, filename), 'rb')
                tube = pickle.load(new_data_file)
                new_data_file.close()
                if tube.getID() in tubes:
                    temp = tubes[tube.getID()] + tube
                    tubes[tube.getID()] = temp
                else:
                    tubes[tube.getID()] = tube
                os.remove(os.path.join(new_data_folder, filename))

        tubes.close()

        db_lock.unlock()
        

if __name__ == "__main__":
    new_data_folder = current_folder + "/new_data/"
    for filename in os.listdir(new_data_folder):
        new_data_file = open(new_data_folder + filename, 'r')
        new_data_file.close()
        