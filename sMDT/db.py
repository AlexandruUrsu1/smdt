    ###############################################################################
#   File: db.py
#   Author(s): Paul Johnecheck
#   Date Created: 11 April, 2021
#
#   Purpose: This is the class representing the database.
#    It will act as the main interface for reading and writing to the database. 
#
#   Known Issues:
#
#   Workarounds:
#
###############################################################################


# Import Preparation block.
# Currently only needed so the records in the mains work with the current imports.
import os
import sys

# Adds the folder that file is in to the system path
sMDT_folder_path = os.path.dirname(os.path.abspath(__file__))
new_data_path = os.path.join(sMDT_folder_path, 'new_data')
sys.path.append(sMDT_folder_path)

sys.path.append(current_folder)

from tube import Tube
#from data.dark_current import DarkCurrent, DarkCurrentRecord # Needed?
from data.station import *
from data.swage import SwageRecord
from data.tension import TensionRecord
from data.leak import LeakRecord
from data.dark_current import DarkCurrentRecord
import locks
import shelve
import pickle
import time
import datetime
import random
import re

class db:
    def __init__(self, path="database.s"):
        '''
        Constructor, builds the database object. Gets the path to the database
        '''
        self.path = path
        
    def size(self):
        '''
        Return the integer size of the database. May wait for the database to be unlocked
        '''
        db_lock = locks.Lock("database")
        db_lock.wait()
        tubes = shelve.open(self.path)
        ret_size = len(tubes)
        tubes.close()
        return ret_size
        
       
    def add_tube(self, tube: Tube()):
        '''
        Adds tube to the database. It does so by pickling the tube,
        and adding it to the new_data file for the database manager to add to the database with update()
        '''
        
        dt = datetime.datetime.now()
        timestamp = dt.timestamp()

        filename = str(timestamp) + str(random.randrange(0,999)) + ".tube"

        if not os.path.isdir(new_data_path):
            os.mkdir(new_data_path)

        file_lock = locks.Lock(filename)
        file_lock.lock()
        with open(os.path.join(new_data_folder, filename),"wb") as f:
            pickle.dump(tube, f)
        file_lock.unlock()

    def get_tube(self, id):
        '''
        Returns the tube specified by id. May wait for the database to be unlocked.
        '''
        db_lock = locks.Lock("database")
        db_lock.wait()
        tubes = shelve.open(self.path)
        try:
            ret_tube = tubes[id]
        except KeyError:
            tubes.close()
            raise KeyError
        tubes.close()
        return ret_tube

    


#This object will eventually be moved to the legacy class.
class station_pickler:
    '''
    This class is designed to facilitate the interface between the database manager and the data generated by the stations. 
    This class will take whatever data is generated in the form of a csv file, and will read it into a sMDT tube object. 
    It will then pickle the object into the standard specified for new data for the db manager.
    '''
    def __init__(self, path=os.path.join(sMDT_folder_path, "new_data")):
        '''
        Constructor, builds the pickler object. Gets the path new data folder
        '''
        self.path = path

    '''
    This is the swage pickler function that will pickle every 
    swage csv file that is in the specified directory swagerDirectory
    '''
    def pickle_swage(self, swagerDirectory):
        return 0 # for now so tests don't fail
        

        for filename in os.listdir(swagerDirectory):
            with open(os.path.join(swagerDirectory, filename)) as file:
                for line in file.readlines():
                    line = line.split(',')
                    # Here are the different csv types, there have been 3 versions
                    # The currently used version that includes endplug type 'Protvino' or 'Munich'
                    if len(line) == 9:
                        barcode      = line[0].replace('\r\n', '')
                        rawLength    = float(line[1])
                        swageLength  = float(line[2])
                        sDate        = line[3]
                        cCode        = line[4]
                        eCode        = line[5]
                        comment      = line[6]
                        user         = line[7].replace('\r\n', '')
                        endplug_type = line[8]  # Not stored currently
                    # An earlier version when endplug type wasn't recorded
                    elif len(line) == 8:
                        barcode     = line[0].replace('\r\n', '')
                        rawLength   = float(line[1])
                        swageLength = float(line[2])
                        sDate       = line[3]
                        cCode       = line[4]
                        eCode       = line[5]
                        comment     = line[6]
                        user        = line[7].replace('\r\n', '')
                    # This was the very first iteration where there were only 3 things recorded
                    else:
                        barcode     = line[0].replace('\r\n', '')
                        comment     = line[1]
                        user        = line[2].replace('\r\n', '')
                        rawLength   = None
                        swageLength = None                       
                        eCode       = None
                        cCode       = None
                        # Swager date was stored in the filename in this version
                        sDate = datetime.string_to_datetime(filename, '%m.%d.%Y_%H_%M_%S.csv')

                    tube = Tube()
                    tube.m_tube_id = barcode
                    tube.new_comment(comment)
                    tube.swage.add_record(SwageRecord(raw_length=rawLength,
                                                      swage_length=swageLength,
                                                      clean_code=cCode,
                                                      error_code=eCode,
                                                      date=sDate,
                                                      user=user))

                    pickled_filename = str(random.randrange(0,999)) + \
                                        str(datetime.now().timestamp()) + 'swage.tube'

                    file_lock = locks.Lock(pickled_filename)
                    file_lock.lock()
                    with open(os.path.join(self.path, pickled_filename),"wb") as f: 
                        pickle.dump(tube, f)
                    file_lock.unlock()
        
    '''
    This is the tension pickler function that will pickle every tension csv file 
    that is in the specified directory tensionDirectory
    '''
    def pickle_tension(self, tensionDirectory):
        return 0 # for now to pass tests
        for filename in os.listdir(tensionDirectory):
            with open(filename) as file:
                for line in file.readlines():
                    line = line.split(',')
                    # Check there are 8 columns, else report to terminal
                    if len(line) == 8:
                        user        = line[0]
                        date        = line[1]
                        barcode     = line[2]
                        #not_used   = line[3]
                        #not_used   = line[4]
                        frequency   = line[5]
                        tension     = line[6]
                        #not_used   = line[7]
                    # Report to terminal unknown formats
                    else:
                        print("File " + filename + " has unknown format")
                        continue
                    sDate = datetime.string_to_datetime(date, '%d.%m.%Y_%H_%M_%S')

                    # Create tube instance
                    tube = Tube()
                    tube.m_tube_id = barcode
                    tube.tension.m_user.append(user)
                    tube.tension.add_record(TensionRecord(tension=tension,
                                                          frequency=frequency,
                                                          date=sDate))

                    pickled_filename = str(random.randrange(0,999)) + \
                                        str(datetime.now().timestamp()) + 'tension.tube'

                    # Lock and write tube instance to pickle file
                    file_lock = locks.Lock(pickled_filename)
                    file_lock.lock()
                    with open(os.path.join(self.path, pickled_filename),"wb") as f: 
                        pickle.dump(tube, f)
                    file_lock.unlock()

    '''
    This is the leak rate pickler function that will pickle every leak rate csv file 
    that is in the specified directory leakDirectory
    '''
    def pickle_leak(self, leakDirectory):
        return 0 # for now to pass tests
        for filename in os.listdir(leakDirectory):
            with open(filename) as file:
                for line in file.readlines():
                    line = line.split('\t')
                    # Check there are 6 columns, else report to terminal
                    if len(line) == 6:
                        leak        = line[0]
                        pressure    = line[1]  # Not used
                        pass_fail   = line[2]  # Useless
                        date        = line[3]
                        time        = line[4]
                        user        = line[5]
                    # Report to terminal unknown formats
                    else:
                        print("File " + filename + " has unknown format")
                        continue
                    sDate = datetime.string_to_datetime(date + time, '%m/%d/%Y%H:%M')
                    barcode = filename.split('_')[0]

                    # Create tube instance
                    tube = Tube()
                    tube.m_tube_id = barcode
                    tube.leak.m_user.append(user)
                    tube.leak.add_record(LeakRecord(leak_rate=leak,
                                                          date=sDate))

                    pickled_filename = str(random.randrange(0,999)) + \
                                        str(datetime.now().timestamp()) + 'leak.tube'

                    # Lock and write tube instance to pickle file
                    file_lock = locks.Lock(pickled_filename)
                    file_lock.lock()
                    with open(os.path.join(self.path, pickled_filename),"wb") as f: 
                        pickle.dump(tube, f)
                    file_lock.unlock()

    '''
    This is the dark current pickler function that will pickle every dark current csv file 
    that is in the specified directory darkcurrentDirectory
    '''
    def pickle_darkcurrent(self, darkcurrentDirectory):
        return 0 # for now to pass tests
        for filename in os.listdir(darkcurrentDirectory):
            with open(filename) as file:
                for line in file.readlines():
                    line = line.split(',')
                    # Check there are 2 columns, else report to terminal
                    if len(line) == 2:
                        current   = line[0]
                        date      = line[1]
                    # Report to terminal unknown formats
                    else:
                        print("File " + filename + " has unknown format")
                        continue
                    sDate = datetime.string_to_datetime(date, '%d_%m_%Y_%H_%M_%S')
                    barcode = filename.split('.')[0]

                    # Create tube instance
                    tube = Tube()
                    tube.m_tube_id = barcode
                    #tube.dark_current.m_user.append(user)
                    tube.leak.add_record(LeakRecord(dark_current=current,
                                                          date=sDate))

                    pickled_filename = str(random.randrange(0,999)) + \
                                        str(datetime.now().timestamp()) + 'dCurrent.tube'

                    # Lock and write tube instance to pickle file
                    file_lock = locks.Lock(pickled_filename)
                    file_lock.lock()
                    with open(os.path.join(self.path, pickled_filename),"wb") as f: 
                        pickle.dump(tube, f)
                    file_lock.unlock()




class db_manager():
    def __init__(self, path="database.s"):
        '''
        Constructor, builds the database manager object. Gets the path to the database
        '''
        self.path = path

    def wipe(self, confirm=False):
        '''
        Wipes the database. confirm must be "confirm" to proceed. 
        Excercise extreme caution with this, but it is necessary for many test cases.
        '''
        if confirm == 'confirm':
            db_lock = locks.Lock("database")
            db_lock.lock()

            tubes = shelve.open(self.path)
            for key in tubes:
                del tubes[key]

            tubes.close()

            db_lock.unlock()

    def update(self):
        '''
        Updates the database by looking for .p files in the new_data directory.
        They should be pickled tubes, and they will be added to the database
        Needs to be ran after a db object calls add_tube(), otherwise the database will not contain the data in time for get_tube()
        '''

        

        pickler = station_pickler()
        pickler.pickle_swage(os.path.join(sMDT_folder_path, 'SwagerStation', 'SwagerData'))
        #pickler.pickle_tension('TensionStation/output')
        #pickler.pickle_leak('LeakDetector/')
        #pickler.pickle_darkcurrent('DarkCurrent/3015V Dark Current')



        #Lock the database
        db_lock = locks.Lock("database")
        db_lock.lock()

        tubes = shelve.open(self.path)

        for filename in os.listdir(new_data_path): 
            if filename.endswith(".tube"):
                file_lock = locks.Lock(filename)
                file_lock.wait()
                new_data_file = open(os.path.join(new_data_path, filename), 'rb') #open the file
                tube = pickle.load(new_data_path)                                   #load the tube from pickle
                new_data_file.close()                                               #close the file
                if tube.getID() in tubes:                                           #add the tubes to the database
                    temp = tubes[tube.getID()] + tube                           
                    tubes[tube.getID()] = temp                          
                else:
                    tubes[tube.getID()] = tube
                os.remove(os.path.join(new_data_path, filename))                 #delete the file that we added the tube from

        #close the database
        tubes.close()

        #unlock the database
        db_lock.unlock()
        
